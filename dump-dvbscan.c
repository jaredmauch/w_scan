/*
 * Simple MPEG/DVB parser to achieve network/service information without initial tuning data
 *
 * Copyright (C) 2006-2014 Winfried Koehler 
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 * Or, point your browser to http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 *
 * The author can be reached at: w_scan AT gmx-topmail DOT de
 *
 * The project's page is http://wirbel.htpc-forum.de/w_scan/index2.html
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "extended_frontend.h"
#include "si_types.h"
#include "scan.h"
#include "dump-dvbscan.h"
#include "dvbscan.h"
#include "countries.h"
#include "satellites.h"
#include <ctype.h>

// Helper function to trim trailing whitespace
static void trim_trailing_whitespace(char *str) {
    if (str == NULL) return;
    
    size_t len = strlen(str);
    while (len > 0 && isspace((unsigned char)str[len - 1])) {
        str[--len] = '\0';
    }
}


/******************************************************************************
 * print initial tuning data for dvbscan. Nevertheless it should be also
 * reusable for 'w_scan -I <file>', therefore a part of the data might be
 * used later in w_scan.
 *****************************************************************************/

void dvbscan_dump_tuningdata (  FILE *f,
                                struct transponder *t,
                                uint16_t index,
                                struct w_scan_flags * flags,
                                int total_frequencies,
                                int locked_frequencies,
                                pList all_transponders) {
        const char * network_name = t->network_name; 
        if (index == 0) {
                struct tm * ti;
                time_t rawtime;
                time(&rawtime);
                ti = localtime(&rawtime);
                fprintf (f, "#------------------------------------------------------------------------------\n");
                fprintf (f, "# file automatically generated by w_scan\n");
                fprintf (f, "# (http://wirbel.htpc-forum.de/w_scan/index2.html)\n");
                fprintf (f, "#! <w_scan> %d %u %u %s %s </w_scan>\n",
                                flags->version,
                                flags->tuning_timeout,
                                flags->filter_timeout,
                                scantype_to_txt(flags->scantype),
                                flags->scantype == SCAN_SATELLITE?
                                        satellite_to_short_name(flags->list_id):
                                        country_to_short_name(flags->list_id));
                fprintf (f, "#------------------------------------------------------------------------------\n");

                if (flags->scantype == SCAN_SATELLITE)
                        fprintf (f, "# satellite            : %s\n",
                                satellite_to_short_name(flags->list_id));
                else
                        fprintf (f, "# location and provider: <add description here>\n");
                fprintf (f, "# date (yyyy-mm-dd)    : %.04d-%.02d-%.02d\n",
                                        ti->tm_year + 1900, ti->tm_mon + 1, ti->tm_mday);
                fprintf (f, "# frequencies detected : %d\n", total_frequencies);
                fprintf (f, "# frequencies locked   : %d\n", locked_frequencies);
                fprintf (f, "# provided by (opt)    : <your name or email here>\n");
                fprintf (f, "#\n");
                
                // Output frontend status flags for all frequencies that had any signal
                fprintf (f, "#\n");
                fprintf (f, "# Frontend status flags for all frequencies with signal:\n");
                fprintf (f, "# FREQUENCY | FE_HAS_SIGNAL FE_HAS_LOCK FE_HAS_CARRIER FE_HAS_SYNC FE_HAS_VITERBI\n");
                if (all_transponders != NULL) {
                        struct transponder * tp;
                        for(tp = all_transponders->first; tp; tp = tp->next) {
                                if (tp->delsys == SYS_ATSC) { // ATSC frequencies
                                        // Show frequencies that had signal, lock, or carrier
                                        if (tp->frontend_status & (FE_HAS_SIGNAL | FE_HAS_LOCK | FE_HAS_CARRIER)) {
                                                fprintf(f, "# %09d | %-3s %-3s %-3s %-3s %-3s\n",
                                                        tp->frequency,
                                                        (tp->frontend_status & FE_HAS_SIGNAL) ? "YES" : "NO",
                                                        (tp->frontend_status & FE_HAS_LOCK) ? "YES" : "NO",
                                                        (tp->frontend_status & FE_HAS_CARRIER) ? "YES" : "NO",
                                                        (tp->frontend_status & FE_HAS_SYNC) ? "YES" : "NO",
                                                        (tp->frontend_status & FE_HAS_VITERBI) ? "YES" : "NO");
                                                }
                                        }
                                }
                        }

                switch (flags->scantype) {
                        case SCAN_TERRCABLE_ATSC:
                                fprintf (f, "# A[2] <freq> <mod> [# comment]\n");
                                break;
                        case SCAN_CABLE:
                                fprintf (f, "# C[2] <freq> <sr> <fec> <mod> [plp_id] [data_slice_id] [system_id] [# comment]\n");
                                break;
                        case SCAN_TERRESTRIAL:
                                fprintf (f, "# T[2] <freq> <bw> <fec_hi> <fec_lo> <mod>");
                                fprintf (f, " <tm> <guard> <hi> [plp_id] [# comment]\n"); //  [system_id]
                                break;
                        case SCAN_SATELLITE:
                                fprintf (f, "# S[2] <freq> <pol> <sr> <fec> [ro] [mod] [isi] [pls_code] [pls_mode] [# comment]\n");
                                break;
                        default:
                                fatal("%s (%d): UNKNOWN SCAN TYPE %d\n", __FUNCTION__, __LINE__, flags->scantype);
                        };
                fprintf (f, "#------------------------------------------------------------------------------\n");
                }       /* end if index == 0 */
        switch (flags->scantype) {
                case SCAN_TERRCABLE_ATSC:
                        fprintf (f, "A ");
                        fprintf (f, "%9i ",  t->frequency);
                        fprintf (f, "%8s", atsc_mod_to_txt(t->modulation));
                        
                        // Add detailed signal and service information as comments
                        if (t->signal_quality != NULL) {
                                fprintf (f, "\t# Signal: %s (%.1f dBm), SNR: %.1f dB", 
                                        t->signal_quality, t->signal_strength_dbm, t->snr_db);
                                
                                // Add video quality if available
                                if (t->video_resolution != NULL) {
                                        fprintf (f, ", Video: %s", t->video_resolution);
                                }
                                
                                // Add service information if available
                                if (t->services->count > 0) {
                                        struct service *s;
                                        int service_count = 0;
                                        fprintf (f, " | Services: ");
                                        
                                        for(s = (t->services)->first; s; s = s->next) {
                                                if (s->service_name && strlen(s->service_name) > 0) {
                                                        if (service_count > 0) fprintf (f, ", ");
                                                        // Trim trailing whitespace from service name
                                                        trim_trailing_whitespace(s->service_name);
                                                        fprintf (f, "%s", s->service_name);
                                                        if (s->logical_channel_number > 0) {
                                                                // Format ATSC channel number as major:minor
                                                                // Based on the values: 57345 = 56:1, 63489 = 62:1
                                                                // It appears to be stored as (major << 10) | minor
                                                                int major = s->logical_channel_number >> 10;
                                                                int minor = s->logical_channel_number & 0x3FF;
                                                                // Only show :1 channels (major channels only)
                                                                if (minor == 1) {
                                                                        fprintf (f, " (Ch %d:%d)", major, minor);
                                                                } else if (minor == 0) {
                                                                        fprintf (f, " (Ch %d)", major);
                                                                }
                                                        }
                                                        service_count++;
                                                }
                                        }
                                }
                        }
                        break;
                case SCAN_CABLE:
                        fprintf (f, "C ");
                        if (t->delsys == SYS_DVBC2)
                           fprintf (f, "2 %u %u %u", t->plp_id, t->data_slice_id, t->system_id);
                        fprintf (f, "%9i ", t->frequency);
                        fprintf (f, "%7i ", t->symbolrate);
                        fprintf (f, "%4s ", cable_fec_to_txt(t->coderate));
                        fprintf (f, "%8s" , cable_mod_to_txt(t->modulation));
                        break;
                case SCAN_TERRESTRIAL:
                        fprintf (f, "%s", t->delsys == SYS_DVBT2?"T2":"T");                           
                        fprintf (f, " %9i ", t->frequency);
                        fprintf (f, "%4s ", terr_bw_to_txt(t->bandwidth));
                        fprintf (f, "%4s ", terr_fec_to_txt(t->coderate));
                        fprintf (f, "%4s ", terr_fec_to_txt(t->coderate_LP));
                        fprintf (f, "%8s ", terr_mod_to_txt(t->modulation));
                        fprintf (f, "%4s ", terr_transmission_to_txt(t->transmission));
                        fprintf (f, "%4s ", terr_guard_to_txt(t->guard));
                        fprintf (f, "%4s",  terr_hierarchy_to_txt(t->hierarchy));
                        if (t->plp_id)
                           fprintf (f, " %u", t->plp_id);
                        break;
                case SCAN_SATELLITE:
                        fprintf (f, "%-2s ", sat_delivery_system_to_txt(t->delsys));
                        fprintf (f, "%8i ",  t->frequency);
                        fprintf (f, "%1s ",  sat_pol_to_txt(t->polarization));
                        fprintf (f, "%8i ",  t->symbolrate);
                        fprintf (f, "%4s",  sat_fec_to_txt(t->coderate));
                        if (t->delsys != SYS_DVBS) {
                                fprintf (f, " %2s ",  sat_rolloff_to_txt(t->rolloff));
                                fprintf (f, "%6s",  sat_mod_to_txt(t->modulation));
                                }
                        break;
                default:
                        ;
                };
        if (network_name != NULL)
                fprintf (f, "\t# %s", network_name);
        fprintf(f, "\n");
}
